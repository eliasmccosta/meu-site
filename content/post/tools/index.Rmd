---
date: "2020-06-15"
diagram: true
image:
  caption: 'Image credit: [**Elias**](https://www.instagram.com/eliasmendescosta/)'
  focal_point: ""
  placement: 3
math: true
title: Ferramentas pedom√©tricas
subtitle: 'Ferramentas pedom√©tricas para an√°lise de pedologia quantitativa'
summary: ''
bibliography: [references.bib]
link-citations: true 
csl: [geoderma-regional.csl]
authors:
- admin
categories:
  - R
  - Programa√ß√£o
tags:
  - MDS
  - Pedometria
nocite: | 
  @R-bookdown
markup:
  goldmark:
    renderer:
      unsafe: true
---

```{r, eval=FALSE, echo=FALSE}
rmarkdown::render('index.Rmd', encoding = 'UTF-8'")
```

# Introdu√ß√£o
Nesse tutorial ser√£o abordados atrav√©s do Algoritmo para Pedologia Quantitativa (AQP em ingl√™s) e pacotes auxiliares, uma cole√ß√£o de c√≥digos, ideias, e plotes usando o software R [@R2019]. Toda a teoria por tr√°s de grande parte do c√≥digo pode ser encontrada no artigo [*Algorithms for quantitative pedology: A toolkit for soil scientists*](https://www.sciencedirect.com/science/article/pii/S009830041200369X?via%3Dihub) [@Beaudette2013]. Al√©m disso alguns exemplos com aplica√ß√µes das ferramentas podem ser encontrados em @Pinheiro2016 e @Pinheiro2018. Para fins did√°ticos o tutorial foi dividido em tr√™s partes e os pacotes usados ser√£o `soilDB`, que cont√©m uma base de dados de solos para an√°lises pedom√©tricas, `AQP` que cont√©m as principais ferramentas de pedologia quantitativa usadas no tutorial, `sharpshootR` que cont√©m uma coel√ß√£o de fun√ß√µes que d√£o suporte ao levantamento e explora√ß√£o de dados de solo, `SP` um pacote que fornece classes e m√©todos para dados espaciais: pontos, linhas, pol√≠gonos e grades, `Hmisc` que cont√©m muitas fun√ß√µes √∫teis para an√°lise de dados, gr√°ficos de alto n√≠vel, opera√ß√µes utilit√°rias, fun√ß√µes para calcular o tamanho de amostras, importar e manipular conjuntos de dados, imputar valores ausentes, cria√ß√£o avan√ßada de tabelas, an√°lise de cluster entre outras fun√ß√µes, `lattice` que √© um sistema de visualiza√ß√£o de dados de alto n√≠vel, poderoso e elegante, com √™nfase em dados multivariados, `MASS` com fun√ß√µes e conjuntos de dados para apoiar Venables e Ripley, **Modern Applied Statistics with S**, `plyr` que cont√©m um conjunto de ferramentas que resolve problemas tais como: Divis√£o, aplica√ß√£o e combina√ß√£o de dados e `cluster` que √© um pacote com m√©todos para an√°lise de componentes principais (PCA) e cluster a fim de encontrar grupos em conjunto de dados. 

## Base de dados dos exerc√≠cios
Todos os dados usados nos exerc√≠cios ou s√£o do pacote `AQP` ou s√£o do pacote `soilDB`. Muitas das informa√ß√µes contidas nesse tutorial foram extra√≠das do [projeto do AQP](http://ncss-tech.github.io/AQP/) e todo cr√©dito √© dado ao autor.

```{r, warning=FALSE, message=FALSE}
# Carregando os pacotes no R
library(soilDB) 
library(aqp)  
library(sharpshootR) 
library(sp) 
library(Hmisc)
library(lattice)
library(MASS)
library(plyr)
library(cluster)
```
# Parte I
Na parte I ser√£o abordadas caracter√≠sticas das fun√ß√µes b√°sicas do *AQP*, conceito de cole√ß√£o de perfis de solos, **SoilProfileCollection**, e verifica√ß√£o da estrutura de dados na cole√ß√£o, al√©m de alguns plotes b√°sicos.
A classe **SoilProfileCollection** foi projetada para simplificar o processo de trabalhar com a cole√ß√£o de dados associados aos perfis de solo: dados em n√≠vel de local (site), dados em n√≠vel de horizonte, dados espaciais, dados de horizontes de diagn√≥sticos, metadados e etc. Os exemplos listados abaixo devem ser copiados/colados deste documento e executados de forma interativa no R. Lembrando que antes de executar voc√™ deve instalar e carregar todas as bibliotecas (pacotes) mencionados. 

## Cria√ß√£o de Objetos
Os objetos **SoilProfileCollection** geralmente s√£o criados atrav√©s de objetos *data.frame* (tabelas retangulares de dados) que cont√™m pelo menos tr√™s colunas essenciais:

- Uma coluna de identifica√ß√£o que identifica exclusivamente grupos de horizontes, um perfil de solo (por exemplo, *pedons*)
- Limites superiores do horizonte
- Limites inferiores do horizonte

O *data.frame* deve ser pr√©-classificado de acordo com o ID do perfil e o limite superior do horizonte. A nota√ß√£o de f√≥rmula √© usada para definir as colunas usadas para promover um objeto *data.frame*.
```{r, warning=FALSE, message=FALSE}
# Carregando dados de solos
# upgrade para SoilProfileCollection
# 'id' √© o nome da coluna que cont√©m o ID do perfil
# 'top' √© o nome da coluna que cont√©m os limite superior do horizonte
# 'bottom' √© o nome da coluna que cont√©m os limite inferior do horizonte
data(sp1) # Conjunto de dados sp4 do pacote AQP (data.frame)
aqp::depths(sp1) <- id ~ top + bottom 
aqp::site(sp1) <- ~ group 
```

## Acessando, configurando e substituindo dados
As fun√ß√µes de acessar s√£o usadas para extrair componentes espec√≠ficos dos objetos **SoilProfileCollection**.
```{r, warning=FALSE, message=FALSE}
# M√©todos para inspe√ß√£o dos objetos
aqp::idname (sp1) # auto-explicativo
aqp::horizonDepths(sp1) # auto-explicativo
aqp::depth_units(sp1) # defaults 'cm'
aqp::metadata(sp1) # 
aqp::profile_id(sp1) # vector com IDs dos perfis
aqp::horizonNames(sp1) # coluna com osnomes dos dados dos horizontes
aqp::siteNames(sp1) # coluna com os nomes do dados dos locais (site data)
length(sp1) # n√∫mero de perfis na cole√ß√£o
nrow(sp1) # n√∫mero de horizontes na cole√ß√£o
names(sp1) # nomes de colunas dos dados do site e do horizonte, concatenados em um √∫nico vetor
min(sp1) # profundidade de perfil mais raso da cole√ß√£o
max(sp1) # profundidade de perfil mais profundo da cole√ß√£o
```

## Dados do horizonte e do site (local)
Normalmente, os dados do horizonte e do site s√£o os componentes mais importantes dos objetos SoilProfileCollection. Ambos s√£o armazenados internamente como objetos data.frame; com uma ou mais linhas (por ID do perfil) na tabela do horizonte e uma linha (por ID do perfil) na tabela do site. As colunas de qualquer tabela podem ser acessadas com a nota√ß√£o `$`. Novos dados podem ser atribu√≠dos a qualquer tabela da mesma maneira, desde que o comprimento dos novos dados sejam:

- Mesmo tamanho que o n√∫mero de perfis na cole√ß√£o (o destino √© a tabela de sites).
- Mesmo comprimento que o n√∫mero de horizontes na cole√ß√£o (o destino √© a tabela do horizonte). 

## Plotando **SoilProfileCollection**
O m√©todo `plot()` para objetos **SoilProfileCollection** gera esbo√ßos de perfis na cole√ß√£o com base nos limites dos horizontes, alinhados verticalmente a uma sequ√™ncia inteira de um ao n√∫mero total de perfis. Os nomes dos horizontes s√£o extra√≠dos automaticamente de um nome de atributo no n√≠vel do horizonte (se presente) ou por meio de um atributo alternativo fornecido como argumento: `name = 'nomedacoula'`. As cores dos horizontes s√£o geradas automaticamente a partir do atributo no n√≠vel do horizonte `soil_color`, ou qualquer outro atributo da descri√ß√£o de cor compat√≠vel com R, fornecido como argumento: `color = 'nomedacoula'`. Essa fun√ß√£o √© altamente personaliz√°vel; portanto, √© prudente consultar a ajuda `(plotSPC)` de tempos em tempos. As cores do solo na nota√ß√£o Munsell podem ser convertidas em cores compat√≠veis com R via `munsell2rgb()`.

```{r, warning=FALSE, message=FALSE}
data(sp4) # Conjunto de dados sp4 do pacote AQP (data.frame)
aqp::depths(sp4) <- id ~ top + bottom 
# Atribui√ß√£o de novos dados a atributos existentes ou novos
sp4$elevation <- rnorm(n=length(sp4), mean=1000, sd=150) # no n√≠vel do site, com base no comprimento dos dados atribu√≠dos
sp4$thickness <- sp4$bottom - sp4$top # n√≠vel do horizonte
# Extra√ß√£o de atributos espec√≠ficos por nome
sp4$clay # Vetor de conte√∫do de argila (dados do horizonte)
```

Os dados do horizonte e do local (site) tamb√©m podem ser modificados por extra√ß√£o para um data.frame, seguidos pela substitui√ß√£o (dados do horizonte) ou jun√ß√£o (dados do site). Observe que, embora essa abordagem ofere√ßa a maior flexibilidade, ela tamb√©m √© a mais perigosa. A substitui√ß√£o dos dados do horizonte por novos dados que n√£o est√£o exatamente de acordo com a classifica√ß√£o original pode corromper seu **SoilProfileCollection**.
```{r, warning=FALSE, message=FALSE}
# extrair dados os horizontes para o data.frame
h <- aqp::horizons(sp4)
# Adicionar uma nova coluna e salvar de volta no objeto
h$random.numbers <- rnorm(n=nrow(h), mean=0, sd=1)
# repor dados originais dos horizontes com vers√£o modificada
#!a ordem das linhas n√£o deve ser alterada!
horizons(sp4) <- h
# extrair dados do site para o data.frame
s <- aqp::site(sp4)
# Adicionar um grupo para o site fake
s$group <- base::factor(rep(c('A', 'B'), length.out=nrow(s)))
# junte novos dados do site com dados anteriores: os dados antigos n√£o s√£o substitu√≠dos
site(sp4) <- s
# Verificar
sp4
```

```{r, warning=FALSE, message=FALSE}
# plot com separa√ß√£o de grupos
aqp::groupedProfilePlot(sp4, groups='group', max.depth=60, group.name.offset = -5, id.style='side')

# Esbo√ßos Tem√°ticos
sp4$clay # 
par(mar=c(1,1,3,1)) # tighter figure margins
plot(sp4, name='name', color='clay',cex.names=0.5,cex.id=0.5, id.style='top',col.legend.cex=1,family="serif", col.label='Argila', )

sp4$Ca # 
par(mar=c(1,1,3,1)) # tighter figure margins
plot(sp4, name='name', color='Ca',cex.names=0.5,cex.id=0.5, id.style='top',col.legend.cex=1,
     col.label='Ca', family="serif")

sp4$name # 
par(mar=c(2,2,3,2)) # tighter figure margins
plot(sp4, name='name', color='name', col.palette=RColorBrewer::brewer.pal(9, 'Set1'), col.label='Nomes dos Horizontes', 
     cex.names=0.5)
###############
### Boxplot ###
# Aqui usaremos o conjunto sp1
sp1$name1 <- aqp::generalize.hz(sp1$name, 
                           new=c('A','AB', 'BA','B','BC', 'C', 'E', 'AE', 'O', 'H', 'R', '2C', '3C', '3B', '3A'), 
                           pat=c('^A','^AB','^BA','^B','^BC','^C', '^E', '^AE', '^O', '^H', '^R', '^2C', '^3C','^3B', '^3A' ))

# compute horizon mid-points 
sp1$mid <- with(horizons(sp1), (top+ bottom)/2)
# sort horizon designation by group-wise median values 
hz.designation.by.median.depths <- names(sort(tapply(sp1$mid, sp1$name1, median)))
# plot the distribution of horizon mid-points by designation 
lattice::bwplot(mid ~ factor(name, levels=hz.designation.by.median.depths),
       data=horizons(sp1),       
       ylim=c(200, 0), ylab='Profundidade do ponto m√©dio do horizonte (cm)',       
       scales=list(y=list(tick.number=10)),       
       panel= function ( ... ) {
         panel.abline(h=seq(0, 180, by=10), v=1:length(hz.designation.by.median.depths), col=grey(0.8), lty=3)    
         panel.bwplot( ... ) })
lattice::bwplot(prop~ factor(name1, levels=hz.designation.by.median.depths),
       data=horizons(sp1),       
       ylab='Profundidade',       
       scales=list(y=list(tick.number=10)),       
       panel= function ( ... ) {  
         panel.abline(h=seq(0, 600, by=50), v=1:length(hz.designation.by.median.depths), col=grey(0.8), lty=3)  
         panel.bwplot( ... ) })
```

# Parte II

## Fun√ß√µes de fatiamento (slice)

Cole√ß√µes de perfis de solo podem ser fatiadas (ou reamostradas) em intervalos regulares de profundidade com a fun√ß√£o `slice()`. A estrutura de fatiamento e as vari√°veis de interesse s√£o definidas por meio de nota√ß√£o de f√≥rmula: seq ~ var.1 + var.2 + var.3 + ... onde seq √© uma sequ√™ncia de n√∫meros inteiros [por exemplo, 0:15 ou c (5,10,15,20) etc.] e var.1 + var.2 + var.3 + ... s√£o atributos no horizonte que se deseja fatiar. As vari√°veis cont√≠nuas e categ√≥ricas podem ser nomeadas no lado direito da f√≥rmula. Os resultados retornados pela fun√ß√£o `slice ()` s√£o **SoilProfileCollection** ou **data.frame** quando chamados com o argumento opcional *just.the.data = TRUE*. Por exemplo, para dividir nosso conjunto de dados de amostra em intervalos de 1 cm, de 0 a 15 cm:

```{r, warning=FALSE, message=FALSE}
# fatiar dados
sliced <- aqp::slice(sp4, fm= 0:50 ~ sand + silt + clay)
# verificar o resultado
class(sliced)
# fatiar de 0 at√© a profundidade m√°xima dos perfis da cole√ß√£o
sliced <- aqp::slice(sp4, fm= 0:max(sp4) ~ sand + silt + clay)
# Extraia todos os dados na faixa de 5--10 cm:
plot(sliced[, 5:10])
# Extraia todos os dados na faixa de 25 a 50 cm:
plot(sliced[, 25:50])
# Extraia todos os dados na faixa de 0--5, 10--20 e 40--50 cm:
plot(sliced[, c(0:5, 10:20, 40:50)])
```

## Agregando cole√ß√µes de perfis de solo em ‚Äúslabs‚Äù regulares
O resumo detalhado dos atributos no n√≠vel de horizonte √© realizado com a fun√ß√£o `slab()`. Os crit√©rios de agrupamento de perfis e a sele√ß√£o de atributos do horizonte s√£o parametrizados por meio da f√≥rmula: grupos ~ var1 + var2 + var3 onde vari√°veis nomeadas s√£o agregadas em grupos ou onde vari√°veis nomeadas s√£o agregadas em toda a cole√ß√£o com f√≥rmula: cole√ß√£o ~ var1 + var2 + var3. A fun√ß√£o de resumo padr√£o *(slab.fun)* calcula os percentis 5, 25, 50, 75 e 95 atrav√©s do estimador de quantil Harrell-Davis.

A estrutura de profundidade ("slabs") sobre a qual os resumos s√£o calculados √© definida com o argumento `slab.structure` usando:

- Um √∫nico n√∫mero inteiro (por exemplo, 10): os dados s√£o agregados em uma sequ√™ncia regular de *slabs* de 10 unidades de espessura.
- Um vetor de 2 n√∫meros inteiros [por exemplo, c (50, 60)]: os dados s√£o agregados em profundidades que variam de 50 a 60 unidades.
- Um vetor de 3 ou mais n√∫meros inteiros [por exemplo, c (0, 5, 10, 50, 100)]: os dados s√£o agregados nas profundidades que variam de 0 a 5, 5 a 10, 10 a 50, 50 a 100 unidades. Essa √© por exemplo umas das formas usadas para harmoniza√ß√£o de dados em profundidades pr√©-definidas como √© o caso do projeto **GlobalSoilMap project** [@Arrouays2017] que √© de 0-5, 5-15, 15-30, 30-60, 60-100, 100-200 cm. 


```{r, warning=FALSE, message=FALSE}
# Agregar cole√ß√µes de perfis de solo em ‚Äúslabs‚Äù (conjuntos) regulares
# calculando o valor m√©dio ignorando os dados ausentes
aqp::slab(sp4, fm= ~ sand + silt + clay, slab.structure=c(0,10), slab.fun=mean, na.rm=TRUE)

# Novamente, desta vez em grupos definidos por um atributo no n√≠vel do site:
aqp::slab(sp4, fm= group ~ sand + silt + clay, slab.structure=c(0,10), slab.fun=mean, na.rm=TRUE)

# Novamente, desta vez em v√°rias faixas de profundidade
aqp::slab(sp4, fm= ~ sand + silt + clay, slab.structure=c(0,5,15,30,60), slab.fun=mean, na.rm=TRUE)

# Novamente, desta vez em fatias de 1 cm, calculando quantis
agg <- aqp::slab(sp4, fm= ~ sand + silt + clay)

# Agregando cole√ß√µes de perfis de solo ao longo de per√≠odos regulares ‚ÄúSlabs‚Äù
lattice::xyplot(top ~ p.q50 | variable, data=agg, ylab='Profundidade (cm)',
       xlab='Mediana delimitada pelos percentis 25 e 75',
       lower=agg$p.q25, upper=agg$p.q75, ylim=c(50,-2),
       panel=panel.depth_function,
       alpha=0.25, sync.colors=TRUE,
       par.settings=list(superpose.line=list(col='RoyalBlue', lwd=2)),
       prepanel=prepanel.depth_function,
       cf=agg$contributing_fraction, cf.col='black', cf.interval=5, 
       layout=c(3,1), strip=strip.custom(bg=grey(0.8)),
       scales=list(x=list(tick.number=4, alternating=3, relation='free'))
)

```

## An√°lise de Dissimilaridade (Dendrogramas)
Os dendrogramas s√£o uma maneira conveniente de descrever a dissimilaridade entre pares (*pair-wise*), comumente associada ao t√≥pico da an√°lise de cluster.
O c√°lculo da dissimilaridade entre perfis √© realizado usando a fun√ß√£o `profile_compare()`. Os valores de dissimilaridade dependem da sele√ß√£o de atributos [por exemplo, argila, CEC, pH etc.], par√¢metro opcional de pondera√ß√£o em profundidade `(k)` e uma profundidade m√°xima de avalia√ß√£o `(max_d)`. Maiores informa√ß√µes dobre an√°lise de dissimilaridade pode ser encontrado em @Beaudette2013 e com exemplos de aplica√ß√£o em @Pinheiro2016 e @Pinheiro2018.

```{r, warning=FALSE, message=FALSE}
# Dissimilaridade usando o conjunto sp4
# usando Ex-Ca:Mg e CTC a pH 7
# sem pondera√ß√£o de profundidade (k = 0)
# at√© uma profundidade m√°xima de 50 cm
d <- aqp::profile_compare(sp4, vars=c('ex_Ca_to_Mg', 'CEC_7'), k=0, max_d=50)

# Verificar matriz de dist√¢ncia
round(d, 1)
# An√°lise hier√°rquica de cluster em um conjunto de dissimilaridades (Hierarchical Clustering)
h <- stats::hclust(d)
# Melhor ajuste de margens
par(mar=c(4,3,2,3))

##Plotando dendrograma
plot(as.dendrogram(h))
#stats::rect.hclust(h,5)

################
# Fazendo de outra forma com fun√ß√£o diana (DIvisive ANAlysis Clustering)
# vizualize a matriz de dissimilaridade via cluster hier√°rquico divisivo
d.diana <- cluster::diana(d)

## Plotando Dendograma
# esta fun√ß√£o √© do pacote sharpshootR
# requer alguns ajustes manuais
par(mar=c(1,1,5,1))
sharpshootR::plotProfileDendrogram(sp4, d.diana, scaling.factor = 0.8, y.offset = 5, width=0.25, color='ex_Ca_to_Mg')

# solos de interesse do levatamento Americano
s.list <- c('hornitos', 'perkins', 'argonaut', 'inks', 'mokelumne',
            'dunstone', 'auburn', 'pentz', 'pardee', 'peters', 
            'amador', 'laniger')

# Buscar e converter dados em um SoilProfileCollection
s <- soilDB::fetchOSD(s.list)
# Estimando a profundidade do solo com base na designa√ß√£o do horizontes
s$soil.depth <- profileApply(s, FUN = max)

# plot profiles, order by soil depth
par(mar=c(0, 0, 0, 0))
plot(s, name='hzname', plot.order=order(s$soil.depth), cex.names=0.85, axis.line.offset=-5, width=0.25, id.style='top')
d <- SoilTaxonomyDendrogram(s, cex.taxon.labels=0.8, width=0.25, y.offset = 0.4)

```


# Parte III
Nessa parte √© usado outra base de dados do `soilDB`, s√£o eles o conjunto `loafercreek` e o conjunto `mineralKing`, e aqui al√©m de plots que marcam os horizontes diagn√≥sticos de alguns perfis s√£o feitos alguns plots que relacionam o perfil e a paisagem. Maiores coment√°rios est√£o na linha de c√≥digo

```{r, warning=FALSE, message=FALSE}
# Carregando onconjunto de dados de solos loafercreek
data("loafercreek")
# selecionar os 10 primeiros perfis
x <- loafercreek[1:10, ]

#reconfigurando as margens porque o default √© muito largo
par(mar=c(1,1,2,1))

# Alguns plots
plot(x)
plot(x, label='pedon_id', id.style='side')
str(x)

# Agrupar perfis pela posi√ß√£o na paisagem
#groupedProfilePlot(x, groups='hillslopeprof', label='pedon_id', id.style='side')

# Carregando onconjunto de dados de solos mineralKing
data("mineralKing")
par(mar=c(1,1,2,1))
groupedProfilePlot(mineralKing, groups='taxonname', print.id=FALSE)

# plot de dist√¢ncia ao longo de um transecto
coordinates(mineralKing) <- ~ x_std + y_std
# defina o sistema de coordenada de refer√™ncia (CRS)
proj4string(mineralKing) <- '+proj=longlat +datum=NAD83'
crs.utm <- CRS('+proj=utm +zone=11 +datum=NAD83') #reprojetando para utm metros
par(mar=c(4.5,4,1,1))

# plot Padr√£o
plotTransect(mineralKing, grad.var.name = 'elev_field', crs = crs.utm)

# plot com altera√ß√£o de tamanho e tipo de fonte e nome dos eixos
plotTransect(mineralKing, grad.var.name='elev_field', crs=crs.utm, grad.axis.title='Eleva√ß√£o (m)', 
             distance.axis.title='Dist√¢ncia ao longo do transecto (km)',
             label='pedon_id', scaling.factor = 0.5,
             cex.names=0.8,cex.id=0.8,col.legend.cex=1.5,family="serif")

```
### Se voc√™ chegou at√© aqui muito bem !!!! üëèüëèüëè

# Refer√™ncias